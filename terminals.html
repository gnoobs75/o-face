<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>≈ç-face Terminal</title>
    <style>
        :root {
            --bg-dark: #0c0c0c;
            --bg-panel: #1a1a1a;
            --border: #333;
            --border-active: #C52638;
            --accent: #C52638;
            --text: #cccccc;
            --text-dim: #666;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-dark);
            font-family: 'Segoe UI', sans-serif;
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Custom title bar */
        .title-bar {
            height: 32px;
            background: var(--bg-panel);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            -webkit-app-region: drag;
            border-bottom: 1px solid var(--border);
        }

        .title-bar-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .title-bar-title {
            font-size: 12px;
            color: var(--text-dim);
            font-weight: 500;
        }

        .title-bar-title span {
            color: var(--accent);
        }

        .layout-buttons {
            display: flex;
            gap: 4px;
            -webkit-app-region: no-drag;
        }

        .layout-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.15s;
        }

        .layout-btn:hover, .layout-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .window-controls {
            display: flex;
            -webkit-app-region: no-drag;
        }

        .window-btn {
            width: 46px;
            height: 32px;
            border: none;
            background: transparent;
            color: var(--text);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .window-btn:hover {
            background: #333;
        }

        .window-btn.close:hover {
            background: #e81123;
            color: white;
        }

        /* Terminal grid */
        .terminal-grid {
            flex: 1;
            display: grid;
            gap: 2px;
            padding: 2px;
            background: var(--bg-dark);
            min-height: 0; /* Critical for flex + grid combo */
            height: calc(100vh - 32px - 24px); /* viewport minus title bar and status bar */
            overflow: hidden;
        }

        .terminal-grid.layout-1 {
            grid-template-rows: 1fr;
            grid-template-columns: 1fr;
        }
        .terminal-grid.layout-2h {
            grid-template-rows: 1fr;
            grid-template-columns: 1fr 1fr;
        }
        .terminal-grid.layout-2v {
            grid-template-rows: 1fr 1fr;
            grid-template-columns: 1fr;
        }
        .terminal-grid.layout-3 {
            grid-template-rows: 1fr 1fr;
            grid-template-columns: 1fr 1fr;
        }
        .terminal-grid.layout-3 .terminal-pane:nth-child(1) { grid-row: span 2; }
        .terminal-grid.layout-4 {
            grid-template-rows: 1fr 1fr;
            grid-template-columns: 1fr 1fr;
        }

        /* Explicit grid placement for 4-pane layout */
        .terminal-grid.layout-4 .terminal-pane:nth-child(1) { grid-row: 1; grid-column: 1; }
        .terminal-grid.layout-4 .terminal-pane:nth-child(2) { grid-row: 1; grid-column: 2; }
        .terminal-grid.layout-4 .terminal-pane:nth-child(3) { grid-row: 2; grid-column: 1; }
        .terminal-grid.layout-4 .terminal-pane:nth-child(4) { grid-row: 2; grid-column: 2; }

        /* Reset for other layouts */
        .terminal-grid.layout-1 .terminal-pane,
        .terminal-grid.layout-2h .terminal-pane,
        .terminal-grid.layout-2v .terminal-pane { grid-row: auto; grid-column: auto; }

        /* Terminal pane */
        .terminal-pane {
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: border-color 0.15s;
            min-height: 0; /* Allow shrinking in grid */
            min-width: 0;
        }

        .terminal-pane.active {
            border-color: var(--border-active);
        }

        .terminal-pane.hidden {
            display: none !important;
        }

        .terminal-pane.visible {
            display: flex !important;
        }

        .pane-header {
            height: 24px;
            background: var(--bg-panel);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            border-bottom: 1px solid var(--border);
            font-size: 11px;
        }

        .pane-title {
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .pane-number {
            background: var(--accent);
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .pane-shell {
            color: var(--text-dim);
        }

        .pane-controls {
            display: flex;
            gap: 4px;
        }

        .pane-btn {
            padding: 2px 6px;
            font-size: 10px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 2px;
        }

        .pane-btn:hover {
            background: var(--border);
            color: var(--text);
        }

        .pane-content {
            flex: 1;
            overflow: hidden;
        }

        .pane-content .xterm {
            height: 100%;
            padding: 4px;
        }

        /* Status bar */
        .status-bar {
            height: 24px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .status-hint kbd {
            background: var(--border);
            padding: 1px 4px;
            border-radius: 2px;
            font-family: inherit;
            margin: 0 2px;
        }

        /* Focus indicator */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .terminal-pane.active .pane-number {
            animation: pulse 2s infinite;
        }

        /* Attention flash for inactive panes */
        @keyframes attention-flash {
            0%, 100% { border-color: var(--border); }
            25%, 75% { border-color: #ff6b00; }
            50% { border-color: #ffaa00; }
        }

        .terminal-pane.attention {
            animation: attention-flash 0.5s ease-in-out 3;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5);
        }

        .terminal-pane.attention .pane-number {
            background: #ff6b00;
        }
    </style>
</head>
<body>
    <div class="title-bar">
        <div class="title-bar-left">
            <span class="title-bar-title"><span>o</span>-face terminal</span>
            <div class="layout-buttons">
                <button class="layout-btn" onclick="setLayout(1)" title="Single">1</button>
                <button class="layout-btn" onclick="setLayout('2h')" title="2 Horizontal">2H</button>
                <button class="layout-btn" onclick="setLayout('2v')" title="2 Vertical">2V</button>
                <button class="layout-btn active" onclick="setLayout(4)" title="Quad">4</button>
            </div>
        </div>
        <div class="window-controls">
            <button class="window-btn" onclick="window.electronAPI.window.minimize()">&#x2212;</button>
            <button class="window-btn" onclick="window.electronAPI.window.maximize()">&#x25A1;</button>
            <button class="window-btn close" onclick="window.electronAPI.window.close()">&#x2715;</button>
        </div>
    </div>

    <div class="terminal-grid layout-4" id="terminalGrid">
        <div class="terminal-pane active" id="pane-0" onclick="focusPane(0)">
            <div class="pane-header">
                <div class="pane-title">
                    <span class="pane-number">1</span>
                    <span class="pane-shell" id="shell-0">PowerShell</span>
                </div>
                <div class="pane-controls">
                    <button class="pane-btn" onclick="clearPane(0)">Clear</button>
                    <button class="pane-btn" onclick="restartPane(0)">Restart</button>
                </div>
            </div>
            <div class="pane-content" id="term-0"></div>
        </div>
        <div class="terminal-pane" id="pane-1" onclick="focusPane(1)">
            <div class="pane-header">
                <div class="pane-title">
                    <span class="pane-number">2</span>
                    <span class="pane-shell" id="shell-1">PowerShell</span>
                </div>
                <div class="pane-controls">
                    <button class="pane-btn" onclick="clearPane(1)">Clear</button>
                    <button class="pane-btn" onclick="restartPane(1)">Restart</button>
                </div>
            </div>
            <div class="pane-content" id="term-1"></div>
        </div>
        <div class="terminal-pane" id="pane-2" onclick="focusPane(2)">
            <div class="pane-header">
                <div class="pane-title">
                    <span class="pane-number">3</span>
                    <span class="pane-shell" id="shell-2">PowerShell</span>
                </div>
                <div class="pane-controls">
                    <button class="pane-btn" onclick="clearPane(2)">Clear</button>
                    <button class="pane-btn" onclick="restartPane(2)">Restart</button>
                </div>
            </div>
            <div class="pane-content" id="term-2"></div>
        </div>
        <div class="terminal-pane" id="pane-3" onclick="focusPane(3)">
            <div class="pane-header">
                <div class="pane-title">
                    <span class="pane-number">4</span>
                    <span class="pane-shell" id="shell-3">PowerShell</span>
                </div>
                <div class="pane-controls">
                    <button class="pane-btn" onclick="clearPane(3)">Clear</button>
                    <button class="pane-btn" onclick="restartPane(3)">Restart</button>
                </div>
            </div>
            <div class="pane-content" id="term-3"></div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-hint">
            <kbd>Ctrl+1-4</kbd> Switch pane
            <kbd>Ctrl+Shift+N</kbd> New pane
            <kbd>Alt+Arrow</kbd> Navigate
        </div>
        <div class="status-info" id="statusInfo">4 panes</div>
    </div>

    <script>
        // Terminal state
        const terminals = {};
        const fitAddons = {};
        let activePane = 0;
        let currentLayout = 4;
        let xtermLoaded = false;

        // Audio context for notification sounds
        let audioCtx = null;

        function playReadySound() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Create a pleasant "ready" chime
            const now = audioCtx.currentTime;

            // First tone
            const osc1 = audioCtx.createOscillator();
            const gain1 = audioCtx.createGain();
            osc1.connect(gain1);
            gain1.connect(audioCtx.destination);
            osc1.frequency.value = 880; // A5
            osc1.type = 'sine';
            gain1.gain.setValueAtTime(0.15, now);
            gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc1.start(now);
            osc1.stop(now + 0.15);

            // Second tone (higher, delayed)
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);
            osc2.frequency.value = 1320; // E6
            osc2.type = 'sine';
            gain2.gain.setValueAtTime(0.15, now + 0.08);
            gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
            osc2.start(now + 0.08);
            osc2.stop(now + 0.25);
        }

        function playAllReadySound() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Triumphant chord when all terminals ready
            const now = audioCtx.currentTime;
            const frequencies = [523.25, 659.25, 783.99, 1046.50]; // C major chord

            frequencies.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = freq;
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.1, now + i * 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5 + i * 0.05);
                osc.start(now + i * 0.05);
                osc.stop(now + 0.5 + i * 0.05);
            });
        }

        function playAttentionSound() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Attention-grabbing notification sound
            const now = audioCtx.currentTime;

            // Three quick ascending tones
            [660, 880, 1100].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = freq;
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.12, now + i * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1 + i * 0.1);
                osc.start(now + i * 0.1);
                osc.stop(now + 0.15 + i * 0.1);
            });
        }

        // Track terminal activity for attention detection
        const terminalActivity = {};
        const PROMPT_PATTERNS = [
            /PS [A-Z]:\\.*>/,           // PowerShell prompt
            /\$\s*$/,                    // Bash prompt
            />\s*$/,                     // Generic prompt
            /claude>\s*$/i,              // Claude prompt
            /\?\s*$/,                    // Question prompt
        ];

        function checkForPrompt(paneIndex, data) {
            // Check if data contains a bell character
            if (data.includes('\x07')) {
                playAttentionSound();
                flashPane(paneIndex);
                return;
            }

            // Track activity
            if (!terminalActivity[paneIndex]) {
                terminalActivity[paneIndex] = {
                    lastOutput: Date.now(),
                    wasActive: false,
                    buffer: ''
                };
            }

            const activity = terminalActivity[paneIndex];
            activity.lastOutput = Date.now();
            activity.wasActive = true;

            // Buffer recent output (keep last 500 chars)
            activity.buffer = (activity.buffer + data).slice(-500);

            // Clear existing timeout
            if (activity.timeout) clearTimeout(activity.timeout);

            // Set timeout to check for prompt after silence
            activity.timeout = setTimeout(() => {
                if (activity.wasActive) {
                    // Check if buffer ends with a prompt pattern
                    const cleanBuffer = activity.buffer.replace(/\x1b\[[0-9;]*m/g, ''); // Strip ANSI
                    for (const pattern of PROMPT_PATTERNS) {
                        if (pattern.test(cleanBuffer)) {
                            playAttentionSound();
                            flashPane(paneIndex);
                            break;
                        }
                    }
                    activity.wasActive = false;
                    activity.buffer = '';
                }
            }, 1500); // 1.5 seconds of silence after activity
        }

        function flashPane(paneIndex) {
            const pane = document.getElementById(`pane-${paneIndex}`);
            if (pane && paneIndex !== activePane) {
                pane.classList.add('attention');
                setTimeout(() => pane.classList.remove('attention'), 2000);
            }
        }

        // Load xterm.js dynamically
        async function loadXterm() {
            if (xtermLoaded) return;

            await loadScript('https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js');
            await loadScript('https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js');
            await loadCSS('https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css');
            xtermLoaded = true;
        }

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function loadCSS(href) {
            return new Promise((resolve) => {
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = href;
                link.onload = resolve;
                document.head.appendChild(link);
            });
        }

        // Create a terminal in a pane
        async function createTerminal(paneIndex) {
            const id = `term-${paneIndex}`;
            const container = document.getElementById(id);

            if (!container || terminals[paneIndex]) return;

            await loadXterm();

            const term = new Terminal({
                theme: {
                    background: '#0c0c0c',
                    foreground: '#cccccc',
                    cursor: '#cccccc',
                    cursorAccent: '#0c0c0c',
                    selection: 'rgba(197, 38, 56, 0.4)',
                    black: '#0c0c0c',
                    red: '#C52638',
                    green: '#16c60c',
                    yellow: '#c19c00',
                    blue: '#569cd6',
                    magenta: '#b4009e',
                    cyan: '#3a96dd',
                    white: '#cccccc',
                    brightBlack: '#767676',
                    brightRed: '#e74856',
                    brightGreen: '#16c60c',
                    brightYellow: '#f9f1a5',
                    brightBlue: '#3b78ff',
                    brightMagenta: '#b4009e',
                    brightCyan: '#61d6d6',
                    brightWhite: '#f2f2f2'
                },
                fontFamily: 'Cascadia Code, Consolas, Monaco, monospace',
                fontSize: 13,
                cursorBlink: true,
                allowTransparency: true
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(container);

            terminals[paneIndex] = term;
            fitAddons[paneIndex] = fitAddon;

            // Fit after a small delay to ensure container is sized
            setTimeout(() => {
                fitAddon.fit();

                // Create PTY process
                window.electronAPI.terminal.create(id).then(result => {
                    if (result.error) {
                        term.writeln('\x1b[31mError: ' + result.error + '\x1b[0m');
                    } else {
                        document.getElementById(`shell-${paneIndex}`).textContent = result.shell;
                        // Send initial resize
                        window.electronAPI.terminal.resize(id, term.cols, term.rows);
                    }
                });
            }, 100);

            // Handle input
            term.onData(data => {
                window.electronAPI.terminal.write(id, data);
            });
        }

        // Focus a pane
        function focusPane(index) {
            document.querySelectorAll('.terminal-pane').forEach((p, i) => {
                p.classList.toggle('active', i === index);
            });
            activePane = index;
            if (terminals[index]) {
                terminals[index].focus();
            }
        }

        // Clear a pane
        function clearPane(index) {
            if (terminals[index]) {
                terminals[index].clear();
            }
        }

        // Restart a pane
        async function restartPane(index) {
            const id = `term-${index}`;
            await window.electronAPI.terminal.kill(id);
            if (terminals[index]) {
                terminals[index].clear();
            }
            const result = await window.electronAPI.terminal.create(id);
            if (result.error) {
                terminals[index]?.writeln('\x1b[31mError: ' + result.error + '\x1b[0m');
            } else {
                document.getElementById(`shell-${index}`).textContent = result.shell;
            }
        }

        // Set layout
        function setLayout(layout) {
            const grid = document.getElementById('terminalGrid');
            grid.className = 'terminal-grid layout-' + layout;
            currentLayout = layout;

            // Update active button
            document.querySelectorAll('.layout-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent === String(layout) ||
                    (layout === '2h' && btn.textContent === '2H') ||
                    (layout === '2v' && btn.textContent === '2V'));
            });

            // Show/hide panes based on layout
            const paneCount = layout === 1 ? 1 : layout === '2h' || layout === '2v' ? 2 : layout === 3 ? 3 : 4;
            document.querySelectorAll('.terminal-pane').forEach((pane, i) => {
                // Explicitly remove both classes first, then add the right one
                pane.classList.remove('hidden', 'visible');
                if (i < paneCount) {
                    pane.classList.add('visible');
                } else {
                    pane.classList.add('hidden');
                }
            });

            // Update status
            document.getElementById('statusInfo').textContent = `${paneCount} pane${paneCount > 1 ? 's' : ''}`;

            // Refit all visible terminals after layout settles
            setTimeout(() => {
                for (let i = 0; i < paneCount; i++) {
                    const container = document.getElementById(`term-${i}`);
                    // Safety check: only fit if container has valid dimensions
                    if (!container || container.offsetWidth < 50 || container.offsetHeight < 50) {
                        continue;
                    }
                    if (fitAddons[i] && terminals[i]) {
                        try {
                            fitAddons[i].fit();
                            const id = `term-${i}`;
                            window.electronAPI.terminal.resize(id, terminals[i].cols, terminals[i].rows);
                        } catch (e) {
                            console.log('Layout fit error for pane', i, e);
                        }
                    }
                }
            }, 150);

            // Make sure active pane is visible
            if (activePane >= paneCount) {
                focusPane(0);
            }
        }

        // Handle terminal data from main process
        if (window.electronAPI) {
            window.electronAPI.terminal.onData((id, data) => {
                const index = parseInt(id.split('-')[1]);
                if (terminals[index]) {
                    terminals[index].write(data);
                    // Check for prompt/attention needed (only for inactive panes)
                    if (index !== activePane) {
                        checkForPrompt(index, data);
                    }
                }
            });

            window.electronAPI.terminal.onExit((id) => {
                const index = parseInt(id.split('-')[1]);
                if (terminals[index]) {
                    terminals[index].writeln('\x1b[33m[Process exited]\x1b[0m');
                }
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+1-4: Switch panes
            if (e.ctrlKey && !e.shiftKey && e.key >= '1' && e.key <= '4') {
                e.preventDefault();
                const pane = parseInt(e.key) - 1;
                const paneCount = currentLayout === 1 ? 1 : currentLayout === '2h' || currentLayout === '2v' ? 2 : currentLayout === 3 ? 3 : 4;
                if (pane < paneCount) {
                    focusPane(pane);
                }
            }

            // Alt+Arrow: Navigate between panes
            if (e.altKey && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                const paneCount = currentLayout === 1 ? 1 : currentLayout === '2h' || currentLayout === '2v' ? 2 : currentLayout === 3 ? 3 : 4;
                let newPane = activePane;

                if (currentLayout === '2h') {
                    if (e.key === 'ArrowLeft') newPane = 0;
                    if (e.key === 'ArrowRight') newPane = 1;
                } else if (currentLayout === '2v') {
                    if (e.key === 'ArrowUp') newPane = 0;
                    if (e.key === 'ArrowDown') newPane = 1;
                } else if (currentLayout === 4 || currentLayout === 3) {
                    // 2x2 grid navigation
                    const row = Math.floor(activePane / 2);
                    const col = activePane % 2;

                    if (e.key === 'ArrowUp' && row > 0) newPane = activePane - 2;
                    if (e.key === 'ArrowDown' && row < 1) newPane = activePane + 2;
                    if (e.key === 'ArrowLeft' && col > 0) newPane = activePane - 1;
                    if (e.key === 'ArrowRight' && col < 1) newPane = activePane + 1;
                }

                if (newPane !== activePane && newPane < paneCount) {
                    focusPane(newPane);
                }
            }

            // Ctrl+L: Clear current pane
            if (e.ctrlKey && e.key === 'l') {
                // Let it pass through to terminal for native clear
            }
        });

        // Handle resize with debounce and safety checks
        let resizeTimeout;
        window.addEventListener('resize', () => {
            // Debounce - wait for resize to settle
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                Object.keys(fitAddons).forEach(key => {
                    const index = parseInt(key);
                    const container = document.getElementById(`term-${index}`);

                    // Safety check: only fit if container has valid dimensions
                    if (!container || container.offsetWidth < 50 || container.offsetHeight < 50) {
                        return;
                    }

                    if (fitAddons[index] && terminals[index]) {
                        try {
                            fitAddons[index].fit();
                            const id = `term-${index}`;
                            window.electronAPI.terminal.resize(id, terminals[index].cols, terminals[index].rows);
                        } catch (e) {
                            console.log('Resize fit error for pane', index, e);
                        }
                    }
                });
            }, 150); // Wait 150ms after last resize event
        });

        // Initialize with staggered terminal creation
        async function init() {
            // Create terminals with delays to avoid race conditions
            for (let i = 0; i < 4; i++) {
                await createTerminal(i);
                // Wait between creating each terminal
                await new Promise(r => setTimeout(r, 500));
            }
            focusPane(0);
        }

        // Wait for window to be ready
        if (document.readyState === 'complete') {
            init();
        } else {
            window.addEventListener('load', init);
        }
    </script>
</body>
</html>
